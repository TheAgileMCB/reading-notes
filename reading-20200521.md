#### Earthdate 20200521
# Data Seeding
*Data seeding* is the process of populating a database with an initial set of data. EF Core is capable of seeding through several different means.

## Model Seed Data
Seeding data can be associated with an entity type as part of a model configuration. This way, EF core migrations will automatically compute what insert, update, or delete operations be to be applied when databases are updated to newer versions.

**Note: Seed data that is altered outside of migrations may be lost or cause an error.**

The following example illustrates this type of seeding using the *HasData* method:
```
modelBuilder.Entity<Blog>().HasData(new Blog {BlogId = 1, Url = "http://sample.com"});
```

Foreign Keys must be explicitly specified:
```
modelBuilder.Entity<Post>().HasData(
    new Post() { BlogId = 1, PostId = 1, Title = "First post", Content = "Test 1" });
```

You can also use *context.Database.EnsureCreated()* to create a database containing the seed data. *EnsureCreated()* will neither update a schema nor seed data into a database that has already been created. You should also not use *EnsureCreated()* if you intend to us *Migrations*.

A primary key value needs to be specified in this way even if it's usually generated by the database. It will be used to detect changes between migrations. Previously seeded data will be removed if the primary key is changed. This feature, then, is most useful for static data.

## Manual Migration Customization
The Microsoft documentation describes it thusly:
>When a migration is added the changes to the data specified with HasData are transformed to calls to *InsertData()*, *UpdateData()*, and *DeleteData()*. One way of working around some of the limitations of HasData is to manually add these calls or custom operations to the migration instead. An example of that is:
```
migrationBuilder.InsertData(
    table: "Blogs",
    columns: new[] { "Url" },
    values: new object[] { "http://generated.com" });
```

## Custom Initialization Logic
*DbContext.SaveChanges()* is a direct and powerful way to seed data. It works before the main application logic begins executing. It looks as follows:
```
using (var context = new DataSeedingContext())
{
    context.Database.EnsureCreated();

    var testBlog = context.Blogs.FirstOrDefault(b => b.Url == "http://test.com");
    if (testBlog == null)
    {
        context.Blogs.Add(new Blog { Url = "http://test.com" });
    }
    context.SaveChanges();
}
```

Two ways to initialize your custom code are:
- run an initialization application locally
- deploy an initialization app with the main app, which calls the initialization routine and disables or removes the initialization app

You can also potentially automate this feature using *publishing profiles*, which are collections of files that exist to make it easier for developers to publish their applications on the web or other machines.

**Note: The custom seeding code should not be part of normal app execution. This can cause concurrency issues if multiple instances are running and needs the app to have permission to modify the database schema.**
